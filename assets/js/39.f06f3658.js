(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{320:function(t,a,v){"use strict";v.r(a);var _=v(14),s=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"http-https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-https"}},[t._v("#")]),t._v(" HTTP|HTTPS")]),t._v(" "),a("p",[t._v("HTTP 是明文传输，容易受到中间人攻击，不安全。\nHTTPS 语义仍然是 HTTP，只不过是在 HTTP 协议栈中 http 与 tcp 之间插入安全层 SSL/TSL。\n安全层采用对称加密的方式加密传输数据和非对称加密的方式来传输对称密钥，解决 http 数据没有加密、无法验证身份、数据容易纂改三个核心问题。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("HTTP + 加密 + 认证 + 完整性保护 = HTTPS")])]),t._v(" "),a("h2",{attrs:{id:"https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),a("p",[t._v("非对称加密，公钥（客服端）和私钥（服务器）。")]),t._v(" "),a("ul",[a("li",[t._v("HTTPS 就是使用 SSL/TLS 协议进行加密传输。")]),t._v(" "),a("li",[t._v("大致流程：客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个「对称加密的秘钥」，使用「该公钥」加密，传输给服务端，服务端再通过解密拿到该「对称秘钥」，后续的所有信息都通过该「对称秘钥」进行加密解密，完成整个 HTTPS 的流程。")]),t._v(" "),a("li",[t._v("「第三方认证」，最重要的是「数字签名」，避免了获取的公钥是中间人的。")])]),t._v(" "),a("h2",{attrs:{id:"强缓存和协商缓存的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强缓存和协商缓存的区别"}},[t._v("#")]),t._v(" 强缓存和协商缓存的区别")]),t._v(" "),a("ul",[a("li",[t._v("优先查找强缓存，没有命中再查找协商缓存")]),t._v(" "),a("li",[t._v("强缓存状态码是 200，协商缓存是 304")]),t._v(" "),a("li",[t._v("强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，资源是否有更新，服务器肯定知道")]),t._v(" "),a("li",[t._v("大部分 web 服务器都默认开启协商缓存。")]),t._v(" "),a("li",[t._v("目前项目大多数使用缓存方案 ：")])]),t._v(" "),a("p",[t._v("协商缓存一般存储：HTML\n强缓存一般存储：css, image, js，文件名带上 hash")]),t._v(" "),a("h2",{attrs:{id:"强制缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),a("h3",{attrs:{id:"基于-expires"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于-expires"}},[t._v("#")]),t._v(" 基于 Expires")]),t._v(" "),a("p",[t._v("被废弃，过度依赖本地时间")]),t._v(" "),a("h3",{attrs:{id:"基于-cache-control"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于-cache-control"}},[t._v("#")]),t._v(" 基于 Cache-Control")]),t._v(" "),a("p",[t._v("Cache-Control 有 max-age、s-maxage、no-cache、no-store、private、public 这六个属性。")]),t._v(" "),a("ul",[a("li",[t._v("max-age： 决定客户端资源被缓存多久。")]),t._v(" "),a("li",[t._v("s-maxage： 决定代理服务器缓存的时长。")]),t._v(" "),a("li",[t._v("no-cache： 表示是强制进行协商缓存。")]),t._v(" "),a("li",[t._v("no-store： 是表示禁止任何缓存策略。")]),t._v(" "),a("li",[t._v("public： 表示资源即可以被浏览器缓存也可以被代理服务器缓存。")]),t._v(" "),a("li",[t._v("private： 表示资源只能被浏览器缓存。")])]),t._v(" "),a("h2",{attrs:{id:"协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),a("h3",{attrs:{id:"基于-last-modified"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于-last-modified"}},[t._v("#")]),t._v(" 基于 last-modified")]),t._v(" "),a("p",[t._v("基于 last-modified 的协商缓存实现方式是:")]),t._v(" "),a("ul",[a("li",[t._v("首先需要在服务器端读出文件修改时间，")]),t._v(" "),a("li",[t._v("将读出来的修改时间赋给响应头的 last-modified 字段。")]),t._v(" "),a("li",[t._v("最后设置 Cache-Control:no-cache")])]),t._v(" "),a("h3",{attrs:{id:"基于-etag-的协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于-etag-的协商缓存"}},[t._v("#")]),t._v(" 基于 Etag 的协商缓存")]),t._v(" "),a("p",[t._v("Etag 就是将原先协商缓存的比较时间戳的形式修改成了比较文件指纹")]),t._v(" "),a("p",[t._v("文件指纹: 根据文件内容计算出的唯一哈希值。文件内容一旦改变则指纹改变。")]),t._v(" "),a("ul",[a("li",[t._v("Etag 感知文件精准度要高于 Last-Modified")]),t._v(" "),a("li",[t._v("同时使用时，服务器校验优先级 Etag /If-None-Match")]),t._v(" "),a("li",[t._v("Last-Modified 性能上要优于 Etag ，因为 Etag 生成过程中需要服务器付出额外开销，会影响服务器端的性能，所以它并不能完全替代 Last-Modified，只能作为补充和强化")])]),t._v(" "),a("h2",{attrs:{id:"代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代理"}},[t._v("#")]),t._v(" 代理")]),t._v(" "),a("ul",[a("li",[t._v("正向代理：服务器不知道哪一个客服端发来的请求")]),t._v(" "),a("li",[t._v("反向代理：客服端不知道哪个是服务器的响应（用于负载均衡）")])])])}),[],!1,null,null,null);a.default=s.exports}}]);